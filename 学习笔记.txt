1、movl 代表(move)移动，但实际运行中是以拷贝方式实现，例如:movl %eax,%ebx将eax寄存器中的数据移动到%ebx中,移动完成后两个寄存器中均有该值.
2、常用跳转语句
   |----je若值相等则跳转
   |----jg若第二个值大于第一个值则跳转
   |----jge若第二个值大于等于第一个值则跳转
   |----jl若第二个值小于第一个值则跳转
   |----jle若第二个值小于等于第一个值则跳转
   |----jmp无条件跳转。使用该指令无需跟在比较指令之后
   |______________________________________________________
3、寻址方式(28-29)
  3.1、内存地址引用通用格式(除立即模式外):
       地址或偏移 (%基址寄存器，%索引寄存器,比例因子)
       上述格式所有字段均是可选，计算地址公式为:
       结果地址 = 地址或偏移+%基址或偏移量寄存器+比例因子*%索引寄存器
       其中地址或偏移量及比例因子必须为常量，其余两个必须是寄存器。如果省略任何一项将以0代替该项。
  3.2、寻址方式
         |---------直接寻址
         |---------索引寻址
         |---------间接寻址
         |---------基址寻址
         |---------立即寻址
         |---------寄存器寻址
         |_________________

4、常见寄存器及其作用
  4.1 通用寄存器(x64)
     |------rax
     |------rbx
     |------rcx
     |------rdx
     |------rsi
     |------rdi
     |------rbp
     |------rsp(栈指针,指向当前栈顶)
     |------r8(基址指针,在函数调用过程横指向栈顶，通过偏移量访问当前栈变量)
     |------r9
     |------r10
     |------r11
     |------r12
     |------r13
     |------r14
     |------r15
     |__________
   4.2 指令寄存器:指向CPU即将执行的下一条指令

5、数据存储尺寸
    ___________________________________________________________________________________
   | Byte              |   8-bit      |     1byte       |    db                        |
   | Word              |   16-bit     |     2byte       |    dw                        |
   | Double-word       |   32-bit     |     4byte       |    dd                        |
   | Quadword          |   64-bit     |     8byte       |    dq/ddq(128byte integer)   |
   | Double quadword   |   128-bit    |     16byte      |    dt                        |
   |____________________________________________________|______________________________|

6、程序格式
  6.1 注释内容使用;,例如:;我是注释内容
  6.2 常量使用equ定义,例如 SIZE equ 1000
  6.3 变量定义(section .data)
   6.3.1 定义格式 变量名  数据类型  初始值
   6.3.2 例如
     section .data
      var  dd 10
      var1 dw 5000
      var2 dq 100000000
  6.4 bss变量定义(section bss)
    6.4.1: 定义格式 变量名  数据类型(resType)  初始值
    6.4.2: 可用数据类型
       ______________________________________
      |Declaration                           |
      |--------------------------------------|
      |resb             8-bit variable(s)    |
      |resw             16-bit variable(s)   |
      |resd             32-bit variable(s)   |
      |resq             64-bit variable(s)   |
      |resdq            128-bit variable(s)  |
      |______________________________________|
7、86-x64指令
  7.1 指令分类
   7.1.1 数据移动指令
    7.1.1.1 移动指令:mov <dest>,<src>
    7.1.1.2 注意事项
     （1） MOV指令中的源操作数绝对不能是立即数和代码段CS寄存器；
     （2） MOV指令中绝对不允许在两个存储单元之间直接传送数据；
     （3） MOV指令中绝对不允许在两个段寄存器之间直接传送数据；
     （4） MOV指令不会影响标志位
   7.1.2 转换指令
   7.1.3 运算指令
     7.1.3.1 整数相加指令
       指令用法:
        常规加法:add <dest>,<src> (<des>=<des>+<src>)
        进位加法:adc <dest>,<src> (<dest>=<dest>+src)
        自增加法:inc <operand> (inc word [wVar])
     7.1.3.2 整数减法
       指令用法:
         常规减法:sub <dest>,<src> (dest=dest-src)
         变量自减:des <operand>   (operand=operand-1)
   7.1.4 逻辑指令
     7.1.4.1 无条件跳转指令
       jmp <label> (跳转到指定标签处)
     7.1.4.2 条件跳转指令
       指令用法: cmp <op1>,<op2>
       指令解释：该指令执行op1和op2两个操作数进行比较，并将比较结果放到标识寄存器中,紧接着的条件跳转语句从标识寄存器中取出比较结果,
       然后根据比较结果来判断是否执行跳转动作。
   7.1.5 控制指令
  7.2 变量值和地址
   唯一访问内存变量的方式是使用括号([]),省略括号将无法访问到内存中具体的值,取而代之获取到的是变量在内存中的地址，
   如果需要访问地址建议使用lea指令。
   指令格式：lea <reg64>,<mem>   将地址<mem>放到寄存器reg64中
   例子:
    lea rcx,byte [bvar]
    lea rsi,dword [dvar]

8 汇编中的宏定义
 8.1 单行宏定义: %define <name> <content>
 8.2 多行宏定义: %marco <name> <number of arguments>
            ; [body of marco]
            %endmacro
 其中参数通过%引用，%1代表第一个参数，%2代表第二个参数。如果宏定义中存在标签定义，标签前需以%%冠以前缀。
