1、movl 代表(move)移动，但实际运行中是以拷贝方式实现，例如:movl %eax,%ebx将eax寄存器中的数据移动到%ebx中,移动完成后两个寄存器中均有该值.
2、常用跳转语句
   |----je若值相等则跳转
   |----jg若第二个值大于第一个值则跳转
   |----jge若第二个值大于等于第一个值则跳转
   |----jl若第二个值小于第一个值则跳转
   |----jle若第二个值小于等于第一个值则跳转
   |----jmp无条件跳转。使用该指令无需跟在比较指令之后
   |______________________________________________________
3、寻址方式(28-29)
  3.1、内存地址引用通用格式(除立即模式外):
       地址或偏移 (%基址寄存器，%索引寄存器,比例因子)
       上述格式所有字段均是可选，计算地址公式为:
       结果地址 = 地址或偏移+%基址或偏移量寄存器+比例因子*%索引寄存器
       其中地址或偏移量及比例因子必须为常量，其余两个必须是寄存器。如果省略任何一项将以0代替该项。
  3.2、寻址方式
         |---------直接寻址
         |---------索引寻址
         |---------间接寻址
         |---------基址寻址
         |---------立即寻址
         |---------寄存器寻址
         |_________________

4、常见寄存器及其作用
  4.1 通用寄存器(x64)
     |------rax
     |------rbx
     |------rcx
     |------rdx
     |------rsi
     |------rdi
     |------rbp
     |------rsp(栈指针,指向当前栈顶)
     |------r8(基址指针,在函数调用过程横指向栈顶，通过偏移量访问当前栈变量)
     |------r9
     |------r10
     |------r11
     |------r12
     |------r13
     |------r14
     |------r15
     |__________
   4.2 指令寄存器:指向CPU即将执行的下一条指令

5、数据存储尺寸
    ___________________________________________________________________________________
   | Byte              |   8-bit      |     1byte       |    db                        |
   | Word              |   16-bit     |     2byte       |    dw                        |
   | Double-word       |   32-bit     |     4byte       |    dd                        |
   | Quadword          |   64-bit     |     8byte       |    dq/ddq(128byte integer)   |
   | Double quadword   |   128-bit    |     16byte      |    dt                        |
   |____________________________________________________|______________________________|

6、程序格式
  6.1 注释内容使用;,例如:;我是注释内容
  6.2 常量使用equ定义,例如 SIZE equ 1000
  6.3 变量定义(section .data)
   6.3.1 定义格式 变量名  数据类型  初始值
   6.3.2 例如
     section .data
      var  dd 10
      var1 dw 5000
      var2 dq 100000000
  6.4 bss变量定义(section bss)
    6.4.1: 定义格式 变量名  数据类型(resType)  初始值
    6.4.2: 可用数据类型
       ______________________________________
      |Declaration                           |
      |--------------------------------------|
      |resb             8-bit variable(s)    |
      |resw             16-bit variable(s)   |
      |resd             32-bit variable(s)   |
      |resq             64-bit variable(s)   |
      |resdq            128-bit variable(s)  |
      |______________________________________|
7、86-x64指令
  7.1 指令分类
   7.1.1 数据移动指令
    7.1.1.1 移动指令:mov <dest>,<src>
    7.1.1.2 注意事项
     （1） MOV指令中的源操作数绝对不能是立即数和代码段CS寄存器；
     （2） MOV指令中绝对不允许在两个存储单元之间直接传送数据；
     （3） MOV指令中绝对不允许在两个段寄存器之间直接传送数据；
     （4） MOV指令不会影响标志位
   7.1.2 转换指令
   7.1.3 运算指令
     7.1.3.1 整数相加指令
       指令用法:
        常规加法:add <dest>,<src> (<des>=<des>+<src>)
        进位加法:adc <dest>,<src> (<dest>=<dest>+src)
        自增加法:inc <operand> (inc word [wVar])
     7.1.3.2 整数减法
       指令用法:
         常规减法:sub <dest>,<src> (dest=dest-src)
         变量自减:des <operand>   (operand=operand-1)
   7.1.4 逻辑指令
     7.1.4.1 无条件跳转指令
       jmp <label> (跳转到指定标签处)
     7.1.4.2 条件跳转指令
       指令用法: cmp <op1>,<op2>
       指令解释：该指令执行op1和op2两个操作数进行比较，并将比较结果放到标识寄存器中,紧接着的条件跳转语句从标识寄存器中取出比较结果,
       然后根据比较结果来判断是否执行跳转动作。
   7.1.5 控制指令
  7.2 变量值和地址
   唯一访问内存变量的方式是使用括号([]),省略括号将无法访问到内存中具体的值,取而代之获取到的是变量在内存中的地址，
   如果需要访问地址建议使用lea指令。
   指令格式：lea <reg64>,<mem>   将地址<mem>放到寄存器reg64中
   例子:
    lea rcx,byte [bvar]
    lea rsi,dword [dvar]

8 汇编中的宏定义
 8.1 单行宏定义: %define <name> <content>
 8.2 多行宏定义: %marco <name> <number of arguments>
            ; [body of marco]
            %endmacro
 其中参数通过%引用，%1代表第一个参数，%2代表第二个参数。如果宏定义中存在标签定义，标签前需以%%冠以前缀。

9 汇编中的函数
  9.1 函数定义格式:
  global <procName>
  <procName>:
   <function body>
  ret
  9.2 函数中变量定方式
   9.2.1 基于栈动态分配内存变量所需内存
    优点:因为只有当函数被调用时，才会给变量动态分配内存,如果函数未被调用则不会分配内存，故比较省内存
    缺点:由于是运行时动态分配内存，额外增加运行时开销
   9.2.2 使用静态变量
    优点:程序执行时已经分配内存,故不存在运行时内存分配开销
    缺点:由于程序执行时内存已经分配，不管函数是否调用变量内存一直存在
  9.3 注意事项
   9.3.1 整个程序同名函数只能定义一次
   9.3.2 函数定义需要介于开始(start)和结束(last)函数之间
  9.4 函数调用过程个人理解(如有错误请指出)
   假设存在如下调用代码:
       section .data
        SYS_exit       equ     60
        EXIT_SUCCESS   equ     0
        a              dq      0
        b              dq      0
        sum            dq      0

       section .text
       global _start
       _start:
        ;按照c/c++语言调用约定入栈参数
        push b
        push a
        call sum_func

       last:
        mov rax,SYS_exit
        mov rdi,EXIT_SUCCESS
        syscall
       ;函数实现sum=a+b功能
       global sum_func
       sum_func:
        push rbp
        mov rbp,rsp
        mov rax,qword [a]
        add rax,qword [b]
        mov rsp,rbp
        pop rbp
        ret
   调用执行过程：
    ___________________________________________________________________________________________________
        push a                                   ————> rsp
        push b                                   ————> rsp-8
        push call func address (call sum_func)   ————> rsp-16(函数返回地址)
        push rbp                                 ————> 保存调用函数基址地址(rsp-24)
        mov rbp,rsp                              ————> 将rbp指向(rsp-16)这个位置
        mov rax,qword [a]
        add rax,qword [b]
        mov rsp,rbp
        mov rsp,rbp                              ————> 重新将rsp调整到(rsp-24)位置处
        pop rbp                                  ————> 恢复调用函数基址地址,由于pop缘故当前栈
                                                        指针位于(rsp-16)处。
        ret                                      ————> 弹出栈顶值(函数返回地址rsp-16),并将
                                                        指令指针(rip)指向该值,继续执行调用函数余下代码
   _________________________________________________________________________________________________